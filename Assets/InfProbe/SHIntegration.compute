#pragma kernel CSMain


#define MAP_SIZE 64
#define COFF_COUNT 9


TextureCube<float3> TexEnv;
SamplerState samplerTexEnv{
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = Wrap;
    AddressV = Wrap;
    AddressW = Wrap;
};

RWBuffer<float3> BufCoeff;


groupshared float3 BufTmpCoeffAcc[MAP_SIZE][COFF_COUNT];


float3 transformCubeDir(in uint n, in float3 dir){
    switch(n){
    case 0:
        return float3(+dir.x, +dir.y, +dir.z);
    case 1:
        return float3(+dir.x, +dir.y, -dir.z);
    case 2:
        return float3(+dir.z, +dir.y, +dir.x);
    case 3:
        return float3(-dir.z, +dir.y, +dir.x);
    case 4:
        return float3(+dir.x, +dir.z, +dir.y);
    case 5:
        return float3(+dir.x, -dir.z, +dir.y);
    default:
        return dir;
    }
    return dir;
}

void projectOntoSH(in float3 n, in float3 color, out float3 sh[COFF_COUNT]){
    // Cosine kernel
    const float A0 = 3.141593f;
    const float A1 = 2.095395f;
    const float A2 = 0.785398f;

    // Band 0
    sh[0] = 0.282095f * A0 * color;

    // Band 1
    sh[1] = 0.488603f * n.y * A1 * color;
    sh[2] = 0.488603f * n.z * A1 * color;
    sh[3] = 0.488603f * n.x * A1 * color;

    // Band 2
    sh[4] = 1.092548f * n.x * n.y * A2 * color;
    sh[5] = 1.092548f * n.y * n.z * A2 * color;
    sh[6] = 0.315392f * (3.f * n.z * n.z - 1.f) * A2 * color;
    sh[7] = 1.092548f * n.x * n.z * A2 * color;
    sh[8] = 0.546274f * (n.x * n.x - n.y * n.y) * A2 * color;
}


[numthreads(MAP_SIZE, 1, 1)]
void CSMain(
    uint3 uGroupID : SV_GroupID,
    uint3 uDispatchThreadID : SV_DispatchThreadID,
    uint3 uGroupThreadID : SV_GroupThreadID,
    uint uGuroupIndex : SV_GroupIndex
)
{
    float3 vUV = float3(
        ((uDispatchThreadID.x / float(MAP_SIZE)) * 2.f) - 1.f,
        ((uDispatchThreadID.y / float(MAP_SIZE)) * 2.f) - 1.f,
        1.f
        );
    float fLenSq = dot(vUV, vUV);
    float fLenInv = rsqrt(fLenSq);

    vUV = vUV * fLenInv;
    vUV = transformCubeDir(uDispatchThreadID.z, vUV);

    float3 vColor = TexEnv.SampleLevel(samplerTexEnv, vUV, 0);
    float fWeight = 4.f * fLenInv / fLenSq;

    vColor *= fWeight;

    float3 vSH[COFF_COUNT];
    projectOntoSH(vUV, vColor, vSH);

    [unroll]
    for(uint i = 0; i < COFF_COUNT; ++i)
        BufTmpCoeffAcc[uGroupThreadID.x][i] = vSH[i];
    GroupMemoryBarrierWithGroupSync();

    [unroll(MAP_SIZE)]
    for(uint j = MAP_SIZE >> 1; j > 0; j >>= 1){
        if(uGroupThreadID.x < j){
            [unroll]
            for(uint i = 0; i < COFF_COUNT; ++i)
                BufTmpCoeffAcc[uGroupThreadID.x][i] += BufTmpCoeffAcc[uGroupThreadID.x + j][i];
        }
        GroupMemoryBarrierWithGroupSync();
    }

    if(uGroupThreadID.x == 0){
        [unroll]
        for(uint i = 0; i < COFF_COUNT; ++i)
            BufCoeff[uGroupID.z * MAP_SIZE * MAP_SIZE + uGroupID.y * MAP_SIZE + i] = BufTmpCoeffAcc[0][i];
    }
}

