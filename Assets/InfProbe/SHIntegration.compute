#pragma kernel CSMain


#define MAP_SIZE 64
#define COFF_COUNT 9


TextureCube<float3> TexEnv;
SamplerState samplerTexEnv{
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = Wrap;
    AddressV = Wrap;
    AddressW = Wrap;
};

RWBuffer<float> BufCoeff;


groupshared float3 BufTmpCoeffAcc[MAP_SIZE][COFF_COUNT];


void projectOntoSH(in float3 n, in float3 color, out float3 sh[COFF_COUNT]){
    // Cosine kernel
    const float Pi = 3.141593f;
    const float A0 = Pi;
    const float A1 = (2.f * Pi) / 3.f;
    const float A2 = Pi * 0.25f;

    // Band 0
    sh[0] = 0.282095f * A0 * color;

    // Band 1
    sh[1] = 0.488603f * n.y * A1 * color;
    sh[2] = 0.488603f * n.z * A1 * color;
    sh[3] = 0.488603f * n.x * A1 * color;

    // Band 2
    sh[4] = 1.092548f * n.x * n.y * A2 * color;
    sh[5] = 1.092548f * n.y * n.z * A2 * color;
    sh[6] = 0.315392f * (3.f * n.z * n.z - 1.f) * A2 * color;
    sh[7] = 1.092548f * n.x * n.z * A2 * color;
    sh[8] = 0.546274f * (n.x * n.x - n.y * n.y) * A2 * color;
}


[numthreads(MAP_SIZE, 1, 1)]
void CSMain(
    uint3 uGroupID : SV_GroupID,
    uint3 uDispatchThreadID : SV_DispatchThreadID,
    uint3 uGroupThreadID : SV_GroupThreadID,
    uint uGuroupIndex : SV_GroupIndex
)
{
    // cube map coordinate based on SHMath's DirectXMath
    float3 vUV;
    [flatten]
    switch(uDispatchThreadID.z){
    case 0: // positive X
        vUV.z = 1.f - (2.f * float(uDispatchThreadID.x) + 1.f) / float(MAP_SIZE);
        vUV.y = 1.f - (2.f * float(uDispatchThreadID.y) + 1.f) / float(MAP_SIZE);
        vUV.x = 1.f;
        break;
    case 1: // negative X
        vUV.z = -1.f + (2.f * float(uDispatchThreadID.x) + 1.f) / float(MAP_SIZE);
        vUV.y = 1.f - (2.f * float(uDispatchThreadID.y) + 1.f) / float(MAP_SIZE);
        vUV.x = -1.f;
        break;

    case 2: // positive Y
        vUV.z = -1.f + (2.f * float(uDispatchThreadID.y) + 1.f) / float(MAP_SIZE);
        vUV.y = 1.f;
        vUV.x = -1.f + (2.f * float(uDispatchThreadID.x) + 1.f) / float(MAP_SIZE);
        break;
    case 3: // negative Y
        vUV.z = 1.f - (2.f * float(uDispatchThreadID.y) + 1.f) / float(MAP_SIZE);
        vUV.y = -1.f;
        vUV.x = -1.f + (2.f * float(uDispatchThreadID.x) + 1.f) / float(MAP_SIZE);
        break;

    case 4: // positive Z
        vUV.z = 1.f;
        vUV.y = 1.f - (2.f * float(uDispatchThreadID.y) + 1.f) / float(MAP_SIZE);
        vUV.x = -1.f + (2.f * float(uDispatchThreadID.x) + 1.f) / float(MAP_SIZE);
        break;
    case 5: // negative Z
        vUV.z = -1.f;
        vUV.y = 1.f - (2.f * float(uDispatchThreadID.y) + 1.f) / float(MAP_SIZE);
        vUV.x = 1.f - (2.f * float(uDispatchThreadID.x) + 1.f) / float(MAP_SIZE);
        break;

    default: // error
        vUV.x = 0.f;
        vUV.y = 0.f;
        vUV.z = 0.f;
        break;
    }

    const float fLenSq = dot(vUV, vUV);
    const float fLenInv = rsqrt(fLenSq);

    vUV = vUV * fLenInv;

    float3 vColor = TexEnv.SampleLevel(samplerTexEnv, vUV, 0);
    float fWeight = 4.f * fLenInv / fLenSq;

    vColor *= fWeight;

    float3 vSH[COFF_COUNT];
    projectOntoSH(vUV, vColor, vSH);

    [unroll]
    for(uint i = 0; i < COFF_COUNT; ++i)
        BufTmpCoeffAcc[uGroupThreadID.x][i] = vSH[i];
    GroupMemoryBarrierWithGroupSync();

    [unroll(MAP_SIZE)]
    for(uint j = MAP_SIZE >> 1; j > 0; j >>= 1){
        if(uGroupThreadID.x < j){
            [unroll]
            for(uint i = 0; i < COFF_COUNT; ++i)
                BufTmpCoeffAcc[uGroupThreadID.x][i] += BufTmpCoeffAcc[uGroupThreadID.x + j][i];
        }
        GroupMemoryBarrierWithGroupSync();
    }

    if(uGroupThreadID.x == 0){
        [unroll]
        for(uint i = 0; i < COFF_COUNT; ++i){
            BufCoeff[uGroupID.z * MAP_SIZE * COFF_COUNT * 3 + uGroupID.y * COFF_COUNT * 3 + i * 3 + 0] = BufTmpCoeffAcc[0][i].x;
            BufCoeff[uGroupID.z * MAP_SIZE * COFF_COUNT * 3 + uGroupID.y * COFF_COUNT * 3 + i * 3 + 1] = BufTmpCoeffAcc[0][i].y;
            BufCoeff[uGroupID.z * MAP_SIZE * COFF_COUNT * 3 + uGroupID.y * COFF_COUNT * 3 + i * 3 + 2] = BufTmpCoeffAcc[0][i].z;
        }
    }
}

