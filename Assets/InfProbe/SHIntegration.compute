#pragma kernel CSMain


#define MAP_SIZE 64
#define COFF_COUNT 9


TextureCube<float3> TexEnv;
SamplerState samplerTexEnv{
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = Wrap;
    AddressV = Wrap;
    AddressW = Wrap;
};

RWBuffer<float> BufCoeff;


groupshared float3 BufTmpCoeffAcc[MAP_SIZE][COFF_COUNT];


void projectOntoSH(in float3 n, in float3 color, out float3 sh[COFF_COUNT]){
    // Cosine kernel
    const float Pi = 3.141593f;
    const float A0 = Pi;
    const float A1 = (2.f * Pi) / 3.f;
    const float A2 = Pi * 0.25f;

    // Band 0
    sh[0] = 0.282095f * A0 * color;

    // Band 1
    sh[1] = 0.488603f * n.y * A1 * color;
    sh[2] = 0.488603f * n.z * A1 * color;
    sh[3] = 0.488603f * n.x * A1 * color;

    // Band 2
    sh[4] = 1.092548f * n.x * n.y * A2 * color;
    sh[5] = 1.092548f * n.y * n.z * A2 * color;
    sh[6] = 0.315392f * (3.f * n.z * n.z - 1.f) * A2 * color;
    sh[7] = 1.092548f * n.x * n.z * A2 * color;
    sh[8] = 0.546274f * (n.x * n.x - n.y * n.y) * A2 * color;
}


[numthreads(MAP_SIZE, 1, 1)]
void CSMain(
    uint3 uGroupID : SV_GroupID,
    uint3 uDispatchThreadID : SV_DispatchThreadID,
    uint3 uGroupThreadID : SV_GroupThreadID,
    uint uGuroupIndex : SV_GroupIndex
)
{
    // cube map coordinate based on SHMath of DirectXMath
    float3 vCubeCoord;
    [flatten]
    switch(uDispatchThreadID.z){
    case 0: // positive X
        vCubeCoord.z = 1.f - (2.f * float(uDispatchThreadID.x) + 1.f) / float(MAP_SIZE);
        vCubeCoord.y = 1.f - (2.f * float(uDispatchThreadID.y) + 1.f) / float(MAP_SIZE);
        vCubeCoord.x = 1.f;
        break;
    case 1: // negative X
        vCubeCoord.z = -1.f + (2.f * float(uDispatchThreadID.x) + 1.f) / float(MAP_SIZE);
        vCubeCoord.y = 1.f - (2.f * float(uDispatchThreadID.y) + 1.f) / float(MAP_SIZE);
        vCubeCoord.x = -1.f;
        break;

    case 2: // positive Y
        vCubeCoord.z = -1.f + (2.f * float(uDispatchThreadID.y) + 1.f) / float(MAP_SIZE);
        vCubeCoord.y = 1.f;
        vCubeCoord.x = -1.f + (2.f * float(uDispatchThreadID.x) + 1.f) / float(MAP_SIZE);
        break;
    case 3: // negative Y
        vCubeCoord.z = 1.f - (2.f * float(uDispatchThreadID.y) + 1.f) / float(MAP_SIZE);
        vCubeCoord.y = -1.f;
        vCubeCoord.x = -1.f + (2.f * float(uDispatchThreadID.x) + 1.f) / float(MAP_SIZE);
        break;

    case 4: // positive Z
        vCubeCoord.z = 1.f;
        vCubeCoord.y = 1.f - (2.f * float(uDispatchThreadID.y) + 1.f) / float(MAP_SIZE);
        vCubeCoord.x = -1.f + (2.f * float(uDispatchThreadID.x) + 1.f) / float(MAP_SIZE);
        break;
    case 5: // negative Z
        vCubeCoord.z = -1.f;
        vCubeCoord.y = 1.f - (2.f * float(uDispatchThreadID.y) + 1.f) / float(MAP_SIZE);
        vCubeCoord.x = 1.f - (2.f * float(uDispatchThreadID.x) + 1.f) / float(MAP_SIZE);
        break;

    default: // error
        vCubeCoord.x = 0.f;
        vCubeCoord.y = 0.f;
        vCubeCoord.z = 0.f;
        break;
    }
    vCubeCoord = normalize(vCubeCoord);

    const float fB = -1.f + 1.f / float(MAP_SIZE);
    const float fS = (2.f * (1.f - 1.f / float(MAP_SIZE)) / (float(MAP_SIZE) - 1.f));
    const float3 vSolidUV = float3(float(uDispatchThreadID.x) * fS + fB, float(uDispatchThreadID.y) * fS + fB, 1.f);
    const float fSolidDot = dot(vSolidUV, vSolidUV);
    const float fSolidDotSqrtInv = rsqrt(fSolidDot);

    const float fDiffSolid = (4.f / fSolidDot) * fSolidDotSqrtInv;

    float3 vColor = TexEnv.SampleLevel(samplerTexEnv, vCubeCoord, 0);
    vColor *= fDiffSolid;

    float3 vSH[COFF_COUNT];
    projectOntoSH(vCubeCoord, vColor, vSH);

    [unroll]
    for(uint i = 0; i < COFF_COUNT; ++i)
        BufTmpCoeffAcc[uGroupThreadID.x][i] = vSH[i];
    GroupMemoryBarrierWithGroupSync();

    [unroll(MAP_SIZE)]
    for(uint j = MAP_SIZE >> 1; j > 0; j >>= 1){
        if(uGroupThreadID.x < j){
            [unroll]
            for(uint i = 0; i < COFF_COUNT; ++i)
                BufTmpCoeffAcc[uGroupThreadID.x][i] += BufTmpCoeffAcc[uGroupThreadID.x + j][i];
        }
        GroupMemoryBarrierWithGroupSync();
    }

    if(uGroupThreadID.x == 0){
        [unroll]
        for(uint i = 0; i < COFF_COUNT; ++i){
            BufCoeff[uGroupID.z * MAP_SIZE * COFF_COUNT * 3 + uGroupID.y * COFF_COUNT * 3 + i * 3 + 0] = BufTmpCoeffAcc[0][i].x;
            BufCoeff[uGroupID.z * MAP_SIZE * COFF_COUNT * 3 + uGroupID.y * COFF_COUNT * 3 + i * 3 + 1] = BufTmpCoeffAcc[0][i].y;
            BufCoeff[uGroupID.z * MAP_SIZE * COFF_COUNT * 3 + uGroupID.y * COFF_COUNT * 3 + i * 3 + 2] = BufTmpCoeffAcc[0][i].z;
        }
    }
}

